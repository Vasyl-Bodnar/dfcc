;; This Source Code Form is subject to the terms of the Mozilla Public
;; License, v. 2.0. If a copy of the MPL was not distributed with this
;; file, You can obtain one at http://mozilla.org/MPL/2.0/.

(define-module (buildlib)
  #:autoload (ice-9 optargs) (define*)
  #:autoload (ice-9 ftw) (nftw scandir)
  #:autoload (ice-9 threads) (par-map n-par-map)
  #:autoload (ice-9 binary-ports) (get-bytevector-all put-bytevector put-u8)
  #:autoload (ice-9 textual-ports) (get-line get-string-all)
  #:autoload (ice-9 popen) (open-pipe*)
  #:autoload (srfi srfi-1) (delete-duplicates lset<=)
  #:autoload (srfi srfi-9) (define-record-type)
  #:export (configure compile-c install clean print-config fail warng info))

(define-record-type <c-compiler>
  (make-c-compiler name archiver args incl-args lib-args lib-type hash)
  c-compiler?
  (name c-compiler-name)
  (archiver c-compiler-archiver)
  (args c-compiler-args)
  (incl-args c-compiler-incl-args)
  (lib-args c-compiler-lib-args)
  (lib-type c-compiler-lib-type)
  (hash c-compiler-hash))

(define-record-type <path>
  (make-path root source lib-source build include library executable metadata obj-build)
  path?
  (source path-source)
  (lib-source path-lib-source)
  (build path-build)
  (include path-include)
  (library path-library)
  (executable path-executable)
  (root path-root)
  (metadata path-metadata)
  (obj-build path-obj-build))

(define-record-type <cache>
  (make-cache enable keep-configs)
  cache?
  (enable cache-enabled?)
  (keep-configs cache-keep-configs))

(define-record-type <command>
  (make-command hash sudo rmdir rm cp)
  command?
  (hash command-hash)
  (sudo command-sudo)
  (rmdir command-rmdir)
  (rm command-rm)
  (cp command-cp))

(define-record-type <config>
  (make-config c-compiler paths cache commands verbosity error)
  config?
  (c-compiler config-c-compiler)
  (paths config-paths)
  (cache config-cache)
  (commands config-commands)
  (verbosity config-verbosity)
  (error config-error set-config-error!))

(define (print-config config)
  (display (config-c-compiler config))
  (newline)
  (display (config-paths config))
  (newline)
  (display (config-cache config))
  (newline)
  (display (config-commands config))
  (newline)
  (display "Verbosity Level: ")
  (display (config-verbosity config))
  (newline)
  (display "Errors: ")
  (display (config-error config))
  (newline))

(define fss file-name-separator-string)

(define (info config . strs)
  (when (= (config-verbosity config) 3)
    (display (apply string-append strs))
    (newline))
  #t)

(define (warng config . strs)
  (when (>= (config-verbosity config) 2)
    (display (apply string-append (cons "WARNING: " strs)))
    (newline))
  #t)

;; Errors are '(bad-configure)
(define (fail config fail-kind . strs)
  (when (>= (config-verbosity config) 0)
    (display (apply string-append (cons "FAILURE: " strs)))
    (newline))
  (set-config-error! config (cons fail-kind (config-error config)))
  #f)

(define (check-fail config)
  (null? (config-error config)))

(define (system*-fail config fail-fun . args)
  (let ((result (status:exit-val (apply system* args))))
    (unless (= result 0) (fail-fun config (number->string result)))))

(define (hash-file hash-commands filename)
  (let* ((port (open-pipe* OPEN_READ (car hash-commands) filename))
         (hash (get-line port)))
    (close-port port)
    hash))

;; FIX: This works, but is rather fragile
(define (hash-port hash-commands port)
  (let* ((tmp-port (mkstemp "/tmp/build-XXXXXX"))
         (bv (get-bytevector-all port)))
    (put-bytevector tmp-port bv)
    (force-output tmp-port)
    (let ((hash (hash-file hash-commands (port-filename tmp-port))))
      (delete-file (port-filename tmp-port))
      (close-port tmp-port)
      (string-take hash
                   (do ((i 0 (1+ i)))
                       ((or (>= i (string-length hash))
                            (char=? #\space (string-ref hash i)))
                        i))))))

(define (hash-compiler-info hash-commands c-compiler c-archiver c-args c-incl-args c-lib-args)
  (if (null? hash-commands)
      #f
      (let* ((port (open-pipe* OPEN_READ c-compiler "--version"))
             (str (get-string-all port)))
        (close-port port)
        (let* ((port (open-input-string
                      (string-append str c-archiver (apply string-append (append c-args
                                                                                 c-incl-args
                                                                                 c-lib-args)))))
               (hash (hash-port hash-commands port)))
          (close-input-port port)
          hash))))

(define (get-lib-args link link-path)
  (let* ((delib (lambda (s)
                  (string-append "-l" (if (string-prefix? "lib" s)
                                          (string-drop s 3)
                                          s))))
         (to-str (lambda (l)
                   (delib (if (list? l) (cadr l) l))))
         (static (filter (lambda (l) (and (list? l)
                                          (eq? 'static (car l)))) link))
         (dynamic (filter (lambda (l) (and (list? l)
                                           (eq? 'dynamic (car l)))) link))
         (non-specific (filter (lambda (l) (if (list? l)
                                               (and (not (eq? 'static (car l)))
                                                    (not (eq? 'dynamic (car l))))
                                               #t)) link)))
    (append (map (lambda (lpath) (string-append "-L" lpath)) link-path)
            (map to-str non-specific)
            (if (null? static)
                '()
                (append (list "-Wl,-Bstatic") (map to-str static)))
            (list "-Wl,-Bdynamic")
            (map to-str dynamic))))

(define (make-full-path root src-dir lib-src-dir build-dir obj-dir compiler-hash incl-name lib-name exe-name)
  (let* ((build (in-vicinity root build-dir))
         (meta (in-vicinity build ".metadata"))
         (obj-build (if compiler-hash (in-vicinity meta compiler-hash) (in-vicinity build-dir obj-dir))))
    (make-path (canonicalize-path root)
               (in-vicinity root src-dir)
               (in-vicinity root lib-src-dir)
               (in-vicinity root build-dir)
               (if incl-name (in-vicinity build incl-name) #f)
               (if lib-name (in-vicinity build lib-name) #f)
               (if exe-name (in-vicinity build exe-name) #f)
               meta
               (in-vicinity meta compiler-hash))))

(define (make-real-command hash sudo rmdir rm cp)
  (let ((f (lambda (name) (search-path (parse-path (getenv "PATH")) name))))
    (let ((hash (filter f hash))
          (sudo (filter f sudo))
          (rmdir (filter f rmdir))
          (rm (filter f rm))
          (cp (filter f cp)))
      (make-command hash sudo rmdir rm cp))))

;; lib-type is 'none, 'static, 'dynamic, or 'both
(define* (configure #:optional (conditional #t) #:key (c-compiler "cc") (c-archiver "ar")
                    (root ".") (src-dir "src") (lib-src-dir src-dir) (build-dir "build") (obj-dir "obj")
                    (exe-name #f) (lib-name #f) (lib-type 'none)
                    (sudo #t) (verbosity 3) (cache-enable #t) (cache-keep-configs 3)
                    (optimization "-O0") (debug "-g") (wall "-Wall") (derive '())
                    (include-name #f) (include '()) (link '()) (link-path '()))
  (let* ((command (make-real-command '("b2sum" "sha512sum" "sha256sum" "sha1sum" "md5sum")
                                     '("doas" "sudo") '("rmdir") '("rm") '("cp")))
         (extra-args (append (list optimization debug wall)
                             (map (lambda (der)
                                    (string-append "-D" (if (symbol? der)
                                                            (symbol->string der) der)))
                                  derive)))
         (incl-args (map (lambda (inc) (string-append "-I" inc)) include))
         (lib-args (get-lib-args link link-path))
         (c-compiler (make-c-compiler c-compiler c-archiver extra-args incl-args lib-args lib-type
                                      (hash-compiler-info (command-hash command) c-compiler c-archiver extra-args incl-args lib-args)))
         (path (make-full-path root src-dir lib-src-dir build-dir obj-dir (c-compiler-hash c-compiler) include-name lib-name exe-name))
         (cache (make-cache cache-enable cache-keep-configs))
         (config (make-config c-compiler path cache command (if (> verbosity 3) 3 verbosity) '())))
    ;; We also need to ensure a few system commands are present, and set them accordingly
    (if (not (or exe-name (and lib-name (memq lib-type '(static dynamic both)))))
        (fail config 'bad-configure "You need to provide a name for at least one of executable or a library with the type (one of 'static, 'dynamic, 'both)"))
    (when (and cache-enable (null? (command-hash command)))
      (fail config 'no-hash "Could not find a hash command in PATH"))
    (when (and sudo (null? (command-sudo command)))
      (warng config "Could not find a sudo/doas command in PATH, installing might not be possible"))
    (when (null? (command-rmdir command))
      (warng config "No rmdir in PATH? Using rm -r"))
    (when (null? (command-rm command))
      (fail config 'no-rm "No rm in PATH!?"))
    (when (null? (command-cp command))
      (fail config 'no-cp "No cp in PATH!?"))

    (unless (equal? lib-type 'none)
      (when (and (memq lib-type '(static both))
                 (not (search-path (parse-path (getenv "PATH")) c-archiver)))
        (warng config "Could not find archiver named \"" c-archiver "\" on PATH, cannot do static libraries")))

    (unless (let ((st (stat (path-source path) #f)))
              (and st (eq? (stat:type st) 'directory)))
      (fail config 'no-src "Could not find a source directory named " (path-source path)))
    (unless (let ((st (stat (path-lib-source path) #f)))
              (and st (eq? (stat:type st) 'directory)))
      (fail config 'no-lib-src "Could not find a library source directory named " (path-lib-source path)))
    (unless (let ((st (stat (path-build path) #f)))
              (and st (eq? (stat:type st) 'directory)))
      (info config "Could not find a build directory named " (path-build path))
      (info config "Creating the build directory")
      (mkdir (path-build path)))

    (when cache-enable
      (unless (let ((st (stat (path-metadata path) #f)))
                (and st (eq? (stat:type st) 'directory)))
        (info config "Could not find metadata named" (path-metadata path))
        (info config "Creating new metadata")
        (mkdir (path-metadata path)))
      (unless (c-compiler-hash c-compiler)
        (fail config "Could not make compiler hash")))

    (unless (let ((st (stat (path-obj-build path) #f)))
              (and st (eq? (stat:type st) 'directory)))
      (info config "Could not find an object directory named " (path-obj-build path))
      (info config "Creating the obj directory")
      (mkdir (path-obj-build path)))
    config))

(define (hash-c-file config source-file)
  (let ((c-compiler (config-c-compiler config))
        (command (config-commands config)))
    (let* ((port (apply open-pipe* (append (list OPEN_READ (c-compiler-name c-compiler) "-E") (cdddr (c-compiler-args c-compiler)) (list source-file) (c-compiler-incl-args c-compiler))))
           (str (get-string-all port)))
      (close-port port)
      (if (eof-object? str)
          (fail config "Could not macro expand file " (basename source-file)))
      (let* ((port (open-input-string str))
             (hash (hash-port (command-hash command) port)))
        (close-input-port port)
        hash))))

;; args is one of
;; ('hashed hash obj-filename)
;; ('finished filename obj-filename)
(define (handle-hash config args)
  (case (car args)
    ((hashed) (cadr args))
    ((finished) (hash-c-file config (cadr args)))
    ((unfinished) #f)))

(define (check-cache config src obj hashes)
  (if (file-exists? obj)
      (let* ((file-hash (hash-c-file config src))
             (found (member file-hash hashes)))
        (if found (car found) #f))
      #f))

;; Deletes a flat directory (no subdirectories)
(define (delete-dir config dir)
  (nftw
   dir
   (lambda (filename statinfo flag base level)
     (when (eq? flag 'regular)
       (delete-file filename))
     #t))
  (system*-fail config (lambda (config ret) (fail config 'delete-dir "Could not delete a directory " dir "\nReturned " ret))
                (car (command-rmdir (config-commands config))) dir))

(define (last-dir metadata configs)
  (let* ((potential (sort (map (lambda (f)
                                 (if (file-exists? (in-vicinity (in-vicinity metadata f) "metafile"))
                                     (call-with-input-file (in-vicinity (in-vicinity metadata f) "metafile")
                                       (lambda (port)
                                         (cons (string->number (get-line port)) (in-vicinity metadata f))))
                                     (cons #f (in-vicinity metadata f))))
                               configs) (lambda (x y) (and (car x) (car y) (> (car x) (car y))))))
         (failed (assq #f potential)))
    (if failed (cdr failed) (cdr (car potential)))))

;; objs is a list of one of
;; ('hashed hash obj-filename)
;; ('finished filename obj-filename)
(define* (hash-inputs config objs #:key (num-threads #f))
  (let ((cache (config-cache config))
        (path (config-paths config))
        (rmdir-commands (command-rmdir (config-commands config)))
        (compiler-hash (c-compiler-hash (config-c-compiler config))))
    (when (cache-enabled? cache)
      (info config "Hashing sources")
      (let ((configs (filter (lambda (f)
                               (and (not (equal? f compiler-hash))
                                    (not (equal? f "."))
                                    (not (equal? f ".."))))
                             (scandir (path-metadata path))))
            (hashes (if num-threads
                        (n-par-map num-threads (lambda (obj) (handle-hash config obj)) objs)
                        (par-map (lambda (obj) (handle-hash config obj)) objs))))
        (call-with-output-file (in-vicinity (path-obj-build path) "metafile")
          (lambda (port)
            (display (get-internal-real-time) port)
            (newline port)
            (for-each (lambda (hash)
                        (when hash
                          (display hash port)
                          (newline port)))
                      hashes)))
        (if (>= (length configs) (cache-keep-configs cache))
            (delete-dir config (last-dir (path-metadata path) configs)))))))

(define (compile-c-object-file config src obj)
  (let ((c-compiler (config-c-compiler config)))
    (info config "Compiling " (basename src))
    (let ((result (status:exit-val (apply system* (append (list (c-compiler-name c-compiler)) (c-compiler-args c-compiler) (list "-c" src "-o" obj) (c-compiler-incl-args c-compiler))))))
      (if (= result 0) (list 'finished src obj)
          (list #f "Could not compile a file: " (basename src) "\nReturned " (number->string result))))))

(define (link-exe config objs)
  (info config "Linking an executable")
  (apply system*-fail (cons config (cons (lambda (config ret) (fail config 'link-exe "Could not not link an executable\nReturned " ret))
                                         (cons (c-compiler-name (config-c-compiler config))
                                               (append objs
                                                       (list "-o" (path-executable (config-paths config)))
                                                       (c-compiler-lib-args (config-c-compiler config))))))))

(define (link-lib config objs)
  (let ((c-compiler (config-c-compiler config))
        (path (config-paths config)))
    (when (and (memq (c-compiler-lib-type c-compiler) '(static both)) (c-compiler-archiver c-compiler))
      (info config "Linking a static library")
      (apply system*-fail (cons config (cons (lambda (config ret) (fail config 'link-static "Could not not link a static library\nReturned " ret))
                                             (append (list (c-compiler-archiver c-compiler) "rcs"
                                                           (string-append (path-library path) ".a")) objs)))))
    (when (memq (c-compiler-lib-type c-compiler) '(dynamic both))
      (info config "Linking a dynamic library")
      (apply system*-fail (cons config (cons (lambda (config ret) (fail config 'link-dynamic "Could not not link a dynamic library\nReturned " ret))
                                             (append (list (c-compiler-name c-compiler) "-shared" "-fPIC" "-o"
                                                           (string-append (path-library path) ".so"))
                                                     objs
                                                     (c-compiler-lib-args c-compiler))))))))

;; result is one of
;; ('hashed hash obj-filename)
;; ('unfinished filename obj-filename)
(define (handle-compile config result)
  (case (car result)
    ((hashed) result)
    ((unfinished) (apply compile-c-object-file (cons config (cdr result))))))

;; objs is a list of one of
;; ('hashed hash obj-filename)
;; ('finished filename obj-filename)
;; (#f reason)
(define (check-objs config objs)
  (for-each
   (lambda (obj)
     (unless (car obj)
       (apply fail (append (list config 'compile-fail) (cdr obj)))))
   objs))

;; compiled-objs should be alist of obj and hash
(define* (collect-objs config dir hashes #:optional (compiled-objs '()))
  (let ((c-compiler (config-c-compiler config))
        (path (config-paths config))
        (cache (config-cache config))
        (command (config-commands config))
        (objs '()))
    (nftw
     dir
     (lambda (filename statinfo flag base level)
       (case flag
         ((regular)
          (unless (equal? (basename filename) (basename filename ".c"))
            (let* ((obj-filename (string-append (path-obj-build path) fss (basename filename ".c") ".o"))
                   (hash (and (cache-enabled? cache)
                              (or (assoc-ref compiled-objs obj-filename)
                                  (if hashes
                                      (check-cache config filename obj-filename hashes)
                                      #f)))))
              (if hash
                  (begin
                    (info config "Already compiled, skipping " (basename filename))
                    (set! objs (cons (list 'hashed hash obj-filename) objs)))
                  (set! objs (cons (list 'unfinished filename obj-filename) objs)))))

          #t)
         ((directory) (info config "Entering a directory: " (basename filename)))
         ((invalid-stat) (warng config "Could not stat a file: " (basename filename)))
         ((directory-not-readable) (warng config "Directory is not readable: " (basename filename)))
         ((stale-symlink) (warng config "Could not follow a symlink: " (basename filename))))))
    objs))

(define* (compile-c config #:optional (conditional #t) #:key (num-threads #f))
  (let ((c-compiler (config-c-compiler config))
        (path (config-paths config))
        (cache (config-cache config))
        (command (config-commands config)))
    (when conditional
      (unless config
        (fail config 'no-config "Must run (configure) first"))
      (let* ((handle-par-compile (lambda (res) (handle-compile config res)))
             (metadata (in-vicinity (path-obj-build path) "metafile"))
             (hashes (if (file-exists? metadata)
                         (reverse (call-with-input-file metadata
                                    (lambda (port)
                                      (do ((hash (get-line port) (get-line port))
                                           (list '() (cons hash list)))
                                          ((eof-object? hash) list)))))
                         '()))
             (hashed-exes #f)
             (exe-objs '())
             (lib-objs '()))
        (when (path-executable path)
          (set! exe-objs (collect-objs config (path-source path) hashes))
          (if num-threads
              (set! exe-objs (n-par-map num-threads handle-par-compile exe-objs))
              (set! exe-objs (par-map handle-par-compile exe-objs)))
          (check-objs config exe-objs)
          (if (and (check-fail config)
                   (or (not (file-exists? (path-executable path)))
                       (memq 'finished (map car exe-objs))))
              (link-exe config (map caddr exe-objs))
              (info config "Already linked, skipping executable"))
          (when (and (check-fail config)
                     (memq 'finished (map car exe-objs)))
            (hash-inputs config exe-objs)
            (set! hashed-exes #t)))
        (when (and (path-library path) (memq (c-compiler-lib-type c-compiler) '(static dynamic both)))
          (set! lib-objs (collect-objs config (path-lib-source path) hashes exe-objs))
          (if (string-prefix? (path-source path) (path-lib-source path))
              (begin
                (if num-threads
                    (set! lib-objs (n-par-map num-threads handle-par-compile lib-objs))
                    (set! lib-objs (par-map handle-par-compile lib-objs)))
                (check-objs config lib-objs))
              (info config "Already compiled"))
          (if (and (check-fail config)
                   (or (and (memq (c-compiler-lib-type c-compiler)
                                  '(static both)) (not (file-exists? (string-append (path-library path) ".a"))))
                       (and (memq (c-compiler-lib-type c-compiler)
                                  '(dynamic both)) (not (file-exists? (string-append (path-library path) ".so"))))
                       (memq 'finished (map car lib-objs))))
              (link-lib config (map caddr lib-objs))
              (info config "Already linked, skipping library")))
        (if (and (check-fail config)
                 (not (lset<= equal? lib-objs exe-objs)))
            (hash-inputs config (delete-duplicates (append exe-objs lib-objs)))
            (when (not hashed-exes) (info config "Already hashed all sources"))))))
  config)

(define* (install config #:optional (conditional #t) #:key (prefix "/usr/local"))
  (let ((sudo-commands (command-sudo (config-commands config)))
        (c-compiler (config-c-compiler config))
        (path (config-paths config)))
    (when conditional
      (info "Copying to bin, lib, and include as instructed")
      (let ((cp-command (if (null? sudo-commands) (list "cp") (list (car sudo-commands) "cp")))
            (mkdirp-command (if (null? sudo-commands) (list "mkdir" "-p") (list (car sudo-commands) "mkdir" "-p"))))
        (when (path-executable path)
          (apply system*-fail (cons config (cons (lambda (config ret) (fail config 'copy-exe "Could not copy the executable library\nReturned " ret))
                                                 (append cp-command (list (path-executable path)
                                                                          (string-append (in-vicinity prefix "bin") fss (basename (path-executable path)))))))))
        (when (path-library path)
          (when (memq (c-compiler-lib-type c-compiler) '(static both))
            (apply system*-fail (cons config (cons (lambda (config ret) (fail config 'copy-static "Could not copy the static library\nReturned " ret))
                                                   (append cp-command (list (string-append (path-library path) ".a")
                                                                            (string-append (in-vicinity prefix "lib") fss (basename (string-append (path-library path) ".a")))))))))
          (when (memq (c-compiler-lib-type c-compiler) '(dynamic both))
            (apply system*-fail (cons config (cons (lambda (config ret) (fail config 'copy-dynamic "Could not copy the dynamic library\nReturned " ret))
                                                   (append cp-command (list (string-append (path-library path) ".so")
                                                                            (string-append (in-vicinity prefix "lib") fss (basename (string-append (path-library path) ".so")))))))))
          (let ((headers '()))
            (nftw (path-lib-source path)
                  (lambda (filename statinfo flag base level)
                    (when (eq? flag 'regular)
                      (unless (equal? (basename filename) (basename filename ".h"))
                        (set! headers (cons filename headers))))
                    #t))
            (let* ((subdir-headers (map (lambda (f) (string-drop f (1+ (string-length (path-lib-source path))))) headers))
                   (include-name (if (path-include path) (path-include path) (if (string-prefix? "lib" (basename (path-library path)))
                                                                                 (string-drop (basename (path-library path)) 3) (basename (path-library path)))))
                   (include-folder (in-vicinity (in-vicinity prefix "include") include-name))
                   (mapped-headers (map (lambda (f) (in-vicinity include-folder f)) subdir-headers)))
              (apply system*-fail (cons (lambda (config ret) (fail config 'make-include-dir "Could not make an include directory\nReturned " ret))
                                        (append mkdirp-command (list include-folder))))
              (for-each (lambda (sh h mh)
                          (unless (file-exists? (dirname sh))
                            (apply system*-fail (cons config (cons (lambda (config ret) (fail config 'make-include-subdir "Could not make an include subdirectory\nReturned " ret))
                                                                   (append mkdirp-command (list (dirname mh)))))))
                          (apply system*-fail (cons config (cons (lambda (config ret) (fail config 'copy-header "Could not copy a header files\nReturned " ret))
                                                                 (append cp-command (list h mh))))))
                        subdir-headers headers mapped-headers)))))))
  config)

;; This is a careful clean that tries to target what it itself may have produced
;; If you truly need a nuclear option, it shall be provided
(define* (clean config #:optional (conditional #t) #:key (nuclear #f))
  (let ((rmdir-commands (command-rmdir (config-commands config)))
        (path (config-paths config)))
    (when conditional
      (info config "Cleaning builds")
      (if (or nuclear (null? rmdir-commands))
          (system*-fail config (lambda (config ret) (fail config 'del-build "Could not delete the build directory\nReturned " ret))
                        "rm" "-r" (path-build path))
          (begin
            (when (file-exists? (in-vicinity (path-build path) "obj"))
              (delete-dir config (in-vicinity (path-build path) "obj")))
            (delete-dir config (path-obj-build path))
            (for-each (lambda (dir) (delete-dir config dir))
                      (map (lambda (f) (in-vicinity (path-metadata path) f))
                           (filter (lambda (f) (not (or (equal? f ".") (equal? f ".."))))
                                   (scandir (path-metadata path)))))
            (delete-dir config (path-metadata path))
            (delete-dir config (path-build path))))))
  config)
